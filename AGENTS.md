# AGENTS.md

> Auto-generated by [Auracoil](https://github.com/your-org/auracoil) using GPT 5.2 Pro analysis.
> Last updated: 2026-02-05

This documentation helps AI coding assistants (Claude Code, Codex CLI) work effectively with this codebase.

---

# AGENTS.md

> Documentation for AI coding assistants (Claude Code, Codex CLI).

## Overview

Auracoil is a Node.js CLI that generates and updates AI-assistant-friendly documentation (notably `AGENTS.md`) using GPT‑5.2 Pro via an Oracle-backed workflow (`src/index.ts`, `package.json`). Tech stack: TypeScript (NodeNext ESM via `tsconfig.json`), Commander.js CLI (`src/index.ts`), Vitest tests (`package.json`), Node.js >=20 (`package.json`).

## Quick Start

```bash
# Install
npm install

# Build (required before start)
npm run build

# Run the CLI
node dist/index.js --help
# or
npm start -- --help

# Dev loop (watch compile)
npm run dev

# Tests
npm test
npm run test:run

# Quality gates
npm run lint
npm run typecheck
```

## Architecture

### Directory structure

```txt
package.json                 # CLI metadata, scripts, deps, Node>=20, bin entry
tsconfig.json                # NodeNext ESM TS build -> dist/
src/index.ts                 # CLI entry + command routing (Commander)
src/commands/                # Command handlers (imported by src/index.ts)
dist/                        # Build output (tsc outDir), entry is dist/index.js
AGENTS.md                    # This doc (generated/maintained by Auracoil)
CLAUDE.md                    # Pointer doc (see ./CLAUDE.md)
```

### Key patterns

* **Single CLI entrypoint**: Command registration and argument parsing live in `src/index.ts`.
* **Command-per-module**: Each subcommand is implemented as a handler imported in `src/index.ts` (e.g., `./commands/generate.js`, `./commands/update.js`).
* **ESM-first**: Project is ESM (`package.json` `"type": "module"`) and uses NodeNext resolution (`tsconfig.json`), so source imports intentionally end in `.js` (see `src/index.ts`).

### Data flow

```txt
User runs: auracoil <command> [options]         (bin -> dist/index.js via package.json)
  -> Commander dispatches handler               (src/index.ts)
  -> Handler performs the command’s work        (src/commands/*)
  -> Writes/updates repo artifacts (docs, etc.) (e.g., AGENTS.md, CLAUDE.md)
```

Command surface (wired in `src/index.ts`):

* `init`: initialize config defaults
* `generate`: generate `AGENTS.md` (Oracle required per command description)
* `update`: incremental regeneration
* `capture`: record a solved problem (template-based; no LLM required per description)
* `search`: search captured solutions
* `health`: show coverage/staleness metrics

## Code Conventions

### ESM + TypeScript rules (critical)

* Keep `.js` in relative imports inside `.ts` sources (example: `src/index.ts` imports `./commands/init.js`).
* Use `import`/`export` only; avoid `require()`/`module.exports` (ESM per `package.json`).

### Naming & organization

* Command handlers are named exports ending with `Command` and are imported into `src/index.ts`:

  * `initCommand`, `generateCommand`, `updateCommand`, `captureCommand`, `searchCommand`, `healthCommand` (`src/index.ts`).
* Keep `src/index.ts` as wiring/orchestration only; put behavior in `src/commands/*`.
* Prefer:

  * `camelCase` functions/vars
  * `PascalCase` types/interfaces
  * `SCREAMING_SNAKE_CASE` constants

### Imports

Order imports like `src/index.ts`:

1. External packages (`commander`, `chalk`)
2. Internal relative modules (`./commands/*.js`)

## Gotchas

* **Build output is the runtime**: `npm start` runs `node dist/index.js` (`package.json`), so run `npm run build` after TS changes.
* **`.js` import specifiers in TS are not optional**: NodeNext + ESM requires `.js` in relative imports (see `src/index.ts`, `tsconfig.json`). Adding new modules without this will fail at runtime.
* **Tests aren’t part of `tsc` output**: `tsconfig.json` excludes `**/*.test.ts`; rely on Vitest (`npm test`, `npm run test:run`).
* **“No args” UX is custom**: `src/index.ts` prints a banner and help when `process.argv.slice(2)` is empty; preserve this behavior if refactoring parsing.
* **Node version floor matters**: Features and module behavior assume Node >=20 (`package.json` `"engines"`).

## Common Patterns

### Add a new subcommand (wiring)

In `src/index.ts` (follow the existing `program.command(...).action(...)` pattern):

```ts
import { myCommand } from './commands/my-command.js';

program
  .command('my-command')
  .description('What this does')
  .option('--flag', 'Example flag')
  .action(myCommand);
```

### Command handler module skeleton

Create `src/commands/my-command.ts` (imported using `.js` in `src/index.ts`):

```ts
import type { Command } from 'commander';

type Options = {
  flag?: boolean;
};

export async function myCommand(options: Options, _cmd: Command) {
  if (options.flag) {
    // ...
  }
}
```

### ESM import rule (don’t break runtime)

```ts
// ✅ Correct for NodeNext ESM (as used in src/index.ts)
import { generateCommand } from './commands/generate.js';

// ❌ Incorrect: will break under ESM output
// import { generateCommand } from './commands/generate';
```

### Preserve “show help when no command” behavior

```ts
program.parse();

if (!process.argv.slice(2).length) {
  program.outputHelp();
}
```
---

## Contributing to This Doc

This file is generated by Auracoil. To update:
1. Run `auracoil update` to refresh from codebase changes
2. For custom sections, add them between `<!-- custom:start -->` and `<!-- custom:end -->` markers

<!-- custom:start -->
<!-- Add your custom content here - it will be preserved during updates -->
<!-- custom:end -->
